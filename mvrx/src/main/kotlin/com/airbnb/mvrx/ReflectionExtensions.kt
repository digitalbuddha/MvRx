package com.airbnb.mvrx

import kotlin.reflect.KClass
import kotlin.reflect.KFunction
import kotlin.reflect.full.declaredFunctions
import kotlin.reflect.full.extensionReceiverParameter
import kotlin.reflect.full.functions
import kotlin.reflect.full.instanceParameter
import kotlin.reflect.full.isSubclassOf
import kotlin.reflect.full.memberFunctions

internal val primitiveWrapperMap = mapOf(
    Boolean::class.javaPrimitiveType to Boolean::class.java,
    Byte::class.javaPrimitiveType to Byte::class.javaObjectType,
    Char::class.javaPrimitiveType to Char::class.javaObjectType,
    Double::class.javaPrimitiveType to Double::class.javaObjectType,
    Float::class.javaPrimitiveType to Float::class.javaObjectType,
    Int::class.javaPrimitiveType to Int::class.javaObjectType,
    Long::class.javaPrimitiveType to Long::class.javaObjectType,
    Short::class.javaPrimitiveType to Short::class.javaObjectType
)

internal fun isPrimitiveWrapperOf(targetClass: Class<*>, primitive: Class<*>): Boolean {
    require(primitive.isPrimitive) { "First argument has to be primitive type" }
    return primitiveWrapperMap[primitive] == targetClass
}

internal fun isAssignableTo(from: Class<*>, to: Class<*>): Boolean {
    if (to.isAssignableFrom(from)) {
        return true
    }
    if (from.isPrimitive) {
        return isPrimitiveWrapperOf(to, from)
    }
    return if (to.isPrimitive) {
        isPrimitiveWrapperOf(from, to)
    } else false
}

internal val KClass<*>.isEnum: Boolean
    get() {
        return getIfReflectionSupported {
            this::class.java.isEnum || isSubclassOf(Enum::class)
        } == true
    }

/**
 * True if this is a java primitive type.
 * This will return false for any nullable types, since those can't be represented as java primitives.
 */
internal val KClass<*>.isPrimitiveType: Boolean
    get() {
        return getIfReflectionSupported {
            javaPrimitiveType
        } != null
    }

internal val KClass<*>.isKotlinClass: Boolean
    get() {
        return this.java.declaredAnnotations.any {
            it.annotationClass.qualifiedName == "kotlin.Metadata"
        }
    }

internal val KClass<*>.isObjectInstance: Boolean
    get() {
        return getIfReflectionSupported {
            objectInstance
        } != null
    }

/**
 * Some objects cannot be access with Kotlin reflection, and throw UnsupportedOperationException.
 *
 * The error message is:
 * "This class is an internal synthetic class generated by the Kotlin compiler.
 * It's not a Kotlin class or interface, so the reflection library has no idea what declarations does it have."
 */
internal fun <T> getIfReflectionSupported(block: () -> T): T? {
    return try {
        block()
    } catch (e: UnsupportedOperationException) {
        null
    }
}

@Suppress("UNCHECKED_CAST")
internal fun <T : Any> KClass<T>.copyMethod(): KFunction<T> =
    this.memberFunctions.first { it.name == "copy" } as KFunction<T>

/** Call the copy function of the Data Class receiver. The params are a map of parameter name to value. */
internal fun <T : Any> T.callCopy(vararg params: Pair<String, Any?>): T {
    val paramMap = params.associate { it }
    return this::class.copyMethod().callNamed(paramMap, self = this)
}

/**
 * Invoke a function with the given parameter names.
 *
 * @param params Mapping of parameter name to parameter value
 * @param self The receiver of the function
 * @param extSelf The extension receiver of the function
 */
internal fun <R> KFunction<R>.callNamed(
    params: Map<String, Any?>,
    self: Any? = null,
    extSelf: Any? = null
): R {
    val map = params.mapTo(ArrayList()) { (key, value) ->
        val param = parameters.firstOrNull { it.name == key }
            ?: throw IllegalStateException("No parameter named '$key' found on copy function for '${this.returnType.classifier}'")
        param to value
    }

    if (self != null) map += instanceParameter!! to self
    if (extSelf != null) map += extensionReceiverParameter!! to extSelf
    return callBy(map.toMap())
}

/** Helper to call a function reflectively. */
internal inline fun <reified T> Any.call(functionName: String, vararg args: Any?): T {
    val function = this::class.functions.find { it.name == functionName }
        ?: error("No function found with name $functionName in class ${this.javaClass.name}")

    return function.call(this, *args) as T
}